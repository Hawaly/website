-- =========================================================
-- YOURSTORY AGENCY - COMPLETE DATABASE RECREATION SCRIPT
-- =========================================================
-- Date: 2025-01-03
-- Description: Complete database schema recreation with all features
-- This script consolidates all tables, migrations, and features
-- into a single comprehensive database creation script
-- =========================================================

BEGIN;

-- =========================================================
-- 1. ENUM TYPES
-- =========================================================

CREATE TYPE client_type AS ENUM ('oneshot', 'mensuel');
CREATE TYPE client_status AS ENUM ('actif', 'pause', 'termine', 'potentiel');
CREATE TYPE mandat_status AS ENUM ('en_cours', 'termine', 'annule');
CREATE TYPE invoice_status AS ENUM ('brouillon', 'envoyee', 'payee', 'annulee');
CREATE TYPE expense_type AS ENUM ('client_mandat', 'yourstory');
CREATE TYPE recurrence_type AS ENUM ('oneshot', 'mensuel');
CREATE TYPE task_status AS ENUM ('a_faire', 'en_cours', 'terminee');
CREATE TYPE task_type AS ENUM ('contenu', 'video', 'reunion', 'reporting', 'autre');

-- =========================================================
-- 2. ROLES TABLE
-- =========================================================

CREATE TABLE public.role (
  id SERIAL PRIMARY KEY,
  code VARCHAR(50) UNIQUE NOT NULL,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  redirect_path VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

COMMENT ON TABLE public.role IS 'Rôles utilisateurs avec redirections personnalisées';
COMMENT ON COLUMN public.role.code IS 'Code unique du rôle (admin, client, staff)';
COMMENT ON COLUMN public.role.redirect_path IS 'Chemin de redirection après login';

-- Insert default roles
INSERT INTO public.role (code, name, description, redirect_path) VALUES
  ('admin', 'Administrateur', 'Accès complet à l''application', '/dashboard'),
  ('client', 'Client', 'Accès limité aux données client', '/client-portal'),
  ('staff', 'Employé', 'Accès intermédiaire', '/dashboard');

-- =========================================================
-- 3. CLIENT TABLE
-- =========================================================

CREATE TABLE public.client (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    type client_type NOT NULL,
    status client_status NOT NULL DEFAULT 'potentiel',
    email TEXT,
    phone TEXT,
    company_name TEXT,
    address TEXT,
    zip_code TEXT,
    locality TEXT,
    represented_by TEXT,
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.client IS 'Clients de l''agence YourStory';
COMMENT ON COLUMN public.client.locality IS 'Ville/localité du client';
COMMENT ON COLUMN public.client.represented_by IS 'Représentant du client';

-- =========================================================
-- 4. APP_USER TABLE (Authentication)
-- =========================================================

CREATE TABLE public.app_user (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  role_id INTEGER NOT NULL REFERENCES public.role(id) ON DELETE RESTRICT,
  client_id BIGINT REFERENCES public.client(id) ON DELETE CASCADE,
  is_active BOOLEAN DEFAULT true,
  last_login TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_app_user_email ON public.app_user(email);
CREATE INDEX idx_app_user_role ON public.app_user(role_id);
CREATE INDEX idx_app_user_client ON public.app_user(client_id);

COMMENT ON TABLE public.app_user IS 'Utilisateurs de l''application';
COMMENT ON COLUMN public.app_user.role_id IS 'Référence vers la table role';
COMMENT ON COLUMN public.app_user.client_id IS 'Référence vers client (NULL pour admin/staff)';

-- Create default admin user (password: admin123)
INSERT INTO public.app_user (email, password_hash, role_id, client_id, is_active)
VALUES (
  'admin@yourstory.ch',
  '$2a$10$5vJqMhmYLZCxJzPe5wDmzOjKwDVoGUaXMsJXtmLbJqGqPckZ3Y3Aq',
  (SELECT id FROM public.role WHERE code = 'admin'),
  NULL,
  true
);

-- =========================================================
-- 5. USER_SESSION TABLE
-- =========================================================

CREATE TABLE public.user_session (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id INTEGER NOT NULL REFERENCES public.app_user(id) ON DELETE CASCADE,
  token VARCHAR(500) UNIQUE NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  ip_address VARCHAR(45),
  user_agent TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_session_user ON public.user_session(user_id);
CREATE INDEX idx_session_token ON public.user_session(token);
CREATE INDEX idx_session_expires ON public.user_session(expires_at);

COMMENT ON TABLE public.user_session IS 'Sessions actives des utilisateurs';
COMMENT ON COLUMN public.user_session.token IS 'Token JWT ou session token';
COMMENT ON COLUMN public.user_session.expires_at IS 'Date d''expiration de la session';

-- =========================================================
-- 6. ACTIVITY_LOG TABLE
-- =========================================================

CREATE TABLE public.activity_log (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES public.app_user(id) ON DELETE SET NULL,
  action VARCHAR(100) NOT NULL,
  entity_type VARCHAR(50),
  entity_id INTEGER,
  details JSONB,
  ip_address VARCHAR(45),
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_activity_user ON public.activity_log(user_id);
CREATE INDEX idx_activity_action ON public.activity_log(action);
CREATE INDEX idx_activity_created ON public.activity_log(created_at);

COMMENT ON TABLE public.activity_log IS 'Journal de toutes les actions des utilisateurs';
COMMENT ON COLUMN public.activity_log.action IS 'Type d''action: login, logout, view, create, update, delete';
COMMENT ON COLUMN public.activity_log.entity_type IS 'Type d''entité: strategy, invoice, mandat, etc.';

-- =========================================================
-- 7. MANDAT TABLE (Projects)
-- =========================================================

CREATE TABLE public.mandat (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    client_id BIGINT NOT NULL REFERENCES public.client(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    mandat_type TEXT DEFAULT 'standard',
    status mandat_status NOT NULL DEFAULT 'en_cours',
    start_date DATE,
    end_date DATE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.mandat IS 'Projets/mandats clients';

-- =========================================================
-- 8. MANDAT_TASK TABLE
-- =========================================================

CREATE TABLE public.mandat_task (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    mandat_id BIGINT NOT NULL REFERENCES public.mandat(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    details TEXT,
    type task_type NOT NULL DEFAULT 'autre',
    status task_status NOT NULL DEFAULT 'a_faire',
    due_date DATE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.mandat_task IS 'Tâches associées aux mandats';

-- =========================================================
-- 9. CONTRAT TABLE (Contracts)
-- =========================================================

CREATE TABLE public.contrat (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    client_id BIGINT NOT NULL REFERENCES public.client(id) ON DELETE CASCADE,
    mandat_id BIGINT REFERENCES public.mandat(id) ON DELETE SET NULL,
    contrat_number TEXT NOT NULL UNIQUE,
    file_path TEXT NOT NULL,
    signed_date DATE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.contrat IS 'Contrats clients';

-- =========================================================
-- 10. INVOICE TABLE (Factures)
-- =========================================================

CREATE TABLE public.invoice (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    client_id BIGINT NOT NULL REFERENCES public.client(id) ON DELETE CASCADE,
    mandat_id BIGINT REFERENCES public.mandat(id) ON DELETE SET NULL,
    invoice_number TEXT NOT NULL UNIQUE,
    issue_date DATE NOT NULL,
    due_date DATE,
    total_ht NUMERIC(10,2) NOT NULL DEFAULT 0,
    total_tva NUMERIC(10,2) NOT NULL DEFAULT 0,
    total_ttc NUMERIC(10,2) NOT NULL DEFAULT 0,
    status invoice_status NOT NULL DEFAULT 'brouillon',
    pdf_path TEXT,
    qr_additional_info TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.invoice IS 'Factures clients';
COMMENT ON COLUMN public.invoice.qr_additional_info IS 'Information supplémentaire personnalisable pour le QR-bill (max 140 caractères selon specs SIX)';

-- =========================================================
-- 11. INVOICE_ITEM TABLE
-- =========================================================

CREATE TABLE public.invoice_item (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    invoice_id BIGINT NOT NULL REFERENCES public.invoice(id) ON DELETE CASCADE,
    description TEXT NOT NULL,
    quantity NUMERIC(10,2) NOT NULL DEFAULT 1,
    unit_price NUMERIC(10,2) NOT NULL DEFAULT 0,
    total NUMERIC(10,2) NOT NULL DEFAULT 0
);

COMMENT ON TABLE public.invoice_item IS 'Lignes de facture';

-- =========================================================
-- 12. EXPENSE_CATEGORY TABLE
-- =========================================================

CREATE TABLE public.expense_category (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    is_recurring BOOLEAN NOT NULL DEFAULT FALSE
);

INSERT INTO public.expense_category (name, is_recurring) VALUES
('Logiciels', TRUE),
('Marketing & Publicité', FALSE),
('Déplacements', FALSE),
('Matériel', FALSE),
('Sous-traitance', FALSE),
('Abonnements', TRUE),
('Divers', FALSE);

COMMENT ON TABLE public.expense_category IS 'Catégories de dépenses';

-- =========================================================
-- 13. EXPENSE TABLE
-- =========================================================

CREATE TABLE public.expense (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    type expense_type NOT NULL,
    mandat_id BIGINT REFERENCES public.mandat(id) ON DELETE SET NULL,
    client_id BIGINT REFERENCES public.client(id) ON DELETE SET NULL,
    category_id BIGINT REFERENCES public.expense_category(id) ON DELETE SET NULL,
    label TEXT NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    date DATE NOT NULL,
    is_recurring recurrence_type NOT NULL DEFAULT 'oneshot',
    notes TEXT,
    receipt_path TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_expense_date ON public.expense(date);
CREATE INDEX idx_expense_type ON public.expense(type);

COMMENT ON TABLE public.expense IS 'Dépenses de l''agence';

-- =========================================================
-- 14. COMPANY_SETTINGS TABLE
-- =========================================================

CREATE TABLE public.company_settings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    agency_name TEXT NOT NULL,
    address TEXT,
    zip_code TEXT,
    city TEXT,
    country TEXT,
    phone TEXT,
    email TEXT,
    tva_number TEXT,
    represented_by TEXT,
    iban TEXT,
    qr_iban TEXT
);

INSERT INTO public.company_settings (
    agency_name, address, zip_code, city, country, phone, email, 
    tva_number, represented_by, iban, qr_iban
)
VALUES (
    'YourStory Agency',
    'Rue de la Paix 15',
    '2000',
    'Neuchâtel',
    'Suisse',
    '+41 79 000 00 00',
    'contact@yourstory.ch',
    'CHE-000.000.000',
    'Mohamad Hawaley',
    'CH00 0000 0000 0000 0000 0',
    'CH44 3199 9123 0008 8901 2'
);

COMMENT ON TABLE public.company_settings IS 'Paramètres de l''agence';
COMMENT ON COLUMN public.company_settings.qr_iban IS 'QR-IBAN pour les QR-bills suisses';

-- =========================================================
-- 15. AUDIT_LOG TABLE
-- =========================================================

CREATE TABLE public.audit_log (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES public.app_user(id) ON DELETE CASCADE,
    action TEXT NOT NULL,
    details TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.audit_log IS 'Journal d''audit des actions utilisateurs';

-- =========================================================
-- 16. SOCIAL_MEDIA_STRATEGY TABLE
-- =========================================================

CREATE TABLE public.social_media_strategy (
  id SERIAL PRIMARY KEY,
  client_id INTEGER NOT NULL REFERENCES public.client(id) ON DELETE CASCADE,
  version INTEGER DEFAULT 1,
  status VARCHAR(20) DEFAULT 'brouillon' CHECK (status IN ('brouillon', 'actif', 'archive')),
  
  -- 1. Contexte & objectifs business
  contexte_general TEXT,
  objectifs_business TEXT,
  objectifs_reseaux TEXT,
  
  -- 2. Audience & Personas
  cibles TEXT,
  personas JSONB,
  plateformes TEXT[],
  
  -- 3. Positionnement & identité
  ton_voix TEXT,
  guidelines_visuelles TEXT,
  valeurs_messages TEXT,
  
  -- 4. Piliers de contenu
  piliers_contenu JSONB,
  
  -- 5. Formats & rythme
  formats_envisages TEXT[],
  frequence_calendrier TEXT,
  workflow_roles TEXT,
  
  -- 6. Audit & concurrence
  audit_profils TEXT,
  benchmark_concurrents TEXT,
  
  -- 7. KPIs & suivi
  kpis JSONB,
  cadre_suivi TEXT,
  
  -- 8. Canaux & mix média (PESO)
  owned_media TEXT,
  shared_media TEXT,
  paid_media TEXT,
  earned_media TEXT,
  
  -- 9. Budget & ressources
  temps_humain TEXT,
  outils TEXT,
  budget_pub TEXT,
  
  -- 10. Planning & optimisation
  planning_global TEXT,
  processus_iteration TEXT,
  mise_a_jour TEXT,
  
  -- Métadonnées
  notes_internes TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  created_by VARCHAR(255)
);

CREATE INDEX idx_social_media_strategy_client_id ON social_media_strategy(client_id);
CREATE INDEX idx_social_media_strategy_status ON social_media_strategy(status);

COMMENT ON TABLE public.social_media_strategy IS 'Stratégies social media pour les clients';

-- =========================================================
-- 17. EDITORIAL_CALENDAR TABLE
-- =========================================================

CREATE TABLE public.editorial_calendar (
  id SERIAL PRIMARY KEY,
  strategy_id INTEGER NOT NULL UNIQUE REFERENCES social_media_strategy(id) ON DELETE CASCADE,
  name VARCHAR(255),
  description TEXT,
  start_date DATE,
  end_date DATE,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  CONSTRAINT editorial_calendar_strategy_unique UNIQUE(strategy_id)
);

CREATE INDEX idx_editorial_calendar_strategy_id ON editorial_calendar(strategy_id);

COMMENT ON TABLE public.editorial_calendar IS 'Calendrier éditorial associé à une stratégie social media';

-- =========================================================
-- 18. EDITORIAL_POST TABLE
-- =========================================================

CREATE TABLE public.editorial_post (
  id SERIAL PRIMARY KEY,
  calendar_id INTEGER NOT NULL REFERENCES editorial_calendar(id) ON DELETE CASCADE,
  
  -- Informations du post
  publication_date DATE NOT NULL,
  platform VARCHAR(50) NOT NULL,
  content_type VARCHAR(100),
  title VARCHAR(255) NOT NULL,
  description TEXT,
  
  -- Contenu
  caption TEXT,
  hashtags TEXT[],
  mentions TEXT[],
  media_urls TEXT[],
  
  -- Statut et suivi
  status VARCHAR(20) DEFAULT 'draft' CHECK (status IN ('draft', 'scheduled', 'published', 'cancelled')),
  scheduled_time TIME,
  published_at TIMESTAMP,
  
  -- Métriques
  likes INTEGER DEFAULT 0,
  comments INTEGER DEFAULT 0,
  shares INTEGER DEFAULT 0,
  views INTEGER DEFAULT 0,
  reach INTEGER DEFAULT 0,
  engagement_rate DECIMAL(5,2),
  
  -- Métadonnées
  notes TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  created_by VARCHAR(255)
);

CREATE INDEX idx_editorial_post_calendar_id ON editorial_post(calendar_id);
CREATE INDEX idx_editorial_post_publication_date ON editorial_post(publication_date);
CREATE INDEX idx_editorial_post_platform ON editorial_post(platform);
CREATE INDEX idx_editorial_post_status ON editorial_post(status);
CREATE INDEX idx_editorial_post_calendar_date ON editorial_post(calendar_id, publication_date);

COMMENT ON TABLE public.editorial_post IS 'Posts planifiés dans le calendrier éditorial';

-- =========================================================
-- 19. PERSONA TABLE
-- =========================================================

CREATE TABLE public.persona (
  id SERIAL PRIMARY KEY,
  strategy_id INTEGER NOT NULL REFERENCES social_media_strategy(id) ON DELETE CASCADE,
  nom VARCHAR(255) NOT NULL,
  age_range VARCHAR(50),
  profession VARCHAR(255),
  besoins TEXT,
  problemes TEXT,
  attentes TEXT,
  comportements TEXT,
  canaux_preferes TEXT[],
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_persona_strategy_id ON persona(strategy_id);

COMMENT ON TABLE public.persona IS 'Personas cibles pour les stratégies social media';

-- =========================================================
-- 20. PILIER_CONTENU TABLE
-- =========================================================

CREATE TABLE public.pilier_contenu (
  id SERIAL PRIMARY KEY,
  strategy_id INTEGER NOT NULL REFERENCES social_media_strategy(id) ON DELETE CASCADE,
  titre VARCHAR(255) NOT NULL,
  description TEXT,
  exemples TEXT,
  pourcentage_cible INTEGER CHECK (pourcentage_cible >= 0 AND pourcentage_cible <= 100),
  ordre INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_pilier_contenu_strategy_id ON pilier_contenu(strategy_id);
CREATE INDEX idx_pilier_contenu_ordre ON pilier_contenu(strategy_id, ordre);

COMMENT ON TABLE public.pilier_contenu IS 'Piliers de contenu des stratégies social media';

-- Link posts to content pillars
ALTER TABLE editorial_post 
ADD COLUMN pilier_id INTEGER REFERENCES pilier_contenu(id) ON DELETE SET NULL;

CREATE INDEX idx_editorial_post_pilier_id ON editorial_post(pilier_id);

-- =========================================================
-- 21. KPI TABLE
-- =========================================================

CREATE TABLE public.kpi (
  id SERIAL PRIMARY KEY,
  strategy_id INTEGER NOT NULL REFERENCES social_media_strategy(id) ON DELETE CASCADE,
  nom VARCHAR(255) NOT NULL,
  objectif TEXT,
  valeur_cible DECIMAL(10,2),
  unite VARCHAR(50),
  periodicite VARCHAR(50),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_kpi_strategy_id ON kpi(strategy_id);

COMMENT ON TABLE public.kpi IS 'KPIs (Indicateurs de Performance) des stratégies social media';

-- =========================================================
-- 22. KPI_MESURE TABLE
-- =========================================================

CREATE TABLE public.kpi_mesure (
  id SERIAL PRIMARY KEY,
  kpi_id INTEGER NOT NULL REFERENCES kpi(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  valeur_mesuree DECIMAL(10,2) NOT NULL,
  commentaire TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_kpi_mesure_kpi_id ON kpi_mesure(kpi_id);
CREATE INDEX idx_kpi_mesure_date ON kpi_mesure(kpi_id, date DESC);

COMMENT ON TABLE public.kpi_mesure IS 'Mesures historiques des KPIs';

-- =========================================================
-- 23. TRIGGERS - UPDATE TIMESTAMP
-- =========================================================

-- Generic function for updating timestamps
CREATE OR REPLACE FUNCTION public.set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply to tables with updated_at
CREATE TRIGGER trg_client_set_timestamp
BEFORE UPDATE ON public.client
FOR EACH ROW EXECUTE FUNCTION public.set_timestamp();

CREATE TRIGGER trg_mandat_set_timestamp
BEFORE UPDATE ON public.mandat
FOR EACH ROW EXECUTE FUNCTION public.set_timestamp();

CREATE TRIGGER trg_mandat_task_set_timestamp
BEFORE UPDATE ON public.mandat_task
FOR EACH ROW EXECUTE FUNCTION public.set_timestamp();

CREATE TRIGGER trg_invoice_set_timestamp
BEFORE UPDATE ON public.invoice
FOR EACH ROW EXECUTE FUNCTION public.set_timestamp();

CREATE TRIGGER app_user_updated_at
BEFORE UPDATE ON public.app_user
FOR EACH ROW EXECUTE FUNCTION public.set_timestamp();

CREATE TRIGGER social_media_strategy_updated_at
BEFORE UPDATE ON social_media_strategy
FOR EACH ROW EXECUTE FUNCTION public.set_timestamp();

CREATE TRIGGER editorial_calendar_updated_at
BEFORE UPDATE ON editorial_calendar
FOR EACH ROW EXECUTE FUNCTION public.set_timestamp();

CREATE TRIGGER editorial_post_updated_at
BEFORE UPDATE ON editorial_post
FOR EACH ROW EXECUTE FUNCTION public.set_timestamp();

CREATE TRIGGER persona_updated_at
BEFORE UPDATE ON persona
FOR EACH ROW EXECUTE FUNCTION public.set_timestamp();

CREATE TRIGGER pilier_contenu_updated_at
BEFORE UPDATE ON pilier_contenu
FOR EACH ROW EXECUTE FUNCTION public.set_timestamp();

CREATE TRIGGER kpi_updated_at
BEFORE UPDATE ON kpi
FOR EACH ROW EXECUTE FUNCTION public.set_timestamp();

-- =========================================================
-- 24. TRIGGER - AUTO CREATE EDITORIAL CALENDAR
-- =========================================================

CREATE OR REPLACE FUNCTION create_editorial_calendar_for_strategy()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO editorial_calendar (strategy_id, name)
  VALUES (NEW.id, 'Calendrier éditorial - Stratégie ' || NEW.id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER auto_create_editorial_calendar
AFTER INSERT ON social_media_strategy
FOR EACH ROW
EXECUTE FUNCTION create_editorial_calendar_for_strategy();

-- =========================================================
-- 25. UTILITY FUNCTIONS
-- =========================================================

-- Function to clean up expired sessions
CREATE OR REPLACE FUNCTION cleanup_expired_sessions()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM public.user_session
  WHERE expires_at < NOW();
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION cleanup_expired_sessions IS 'Supprime les sessions expirées (à exécuter via cron)';

-- Function to log activity
CREATE OR REPLACE FUNCTION log_activity(
  p_user_id INTEGER,
  p_action VARCHAR(100),
  p_entity_type VARCHAR(50) DEFAULT NULL,
  p_entity_id INTEGER DEFAULT NULL,
  p_details JSONB DEFAULT NULL,
  p_ip_address VARCHAR(45) DEFAULT NULL
)
RETURNS INTEGER AS $$
DECLARE
  new_id INTEGER;
BEGIN
  INSERT INTO public.activity_log (user_id, action, entity_type, entity_id, details, ip_address)
  VALUES (p_user_id, p_action, p_entity_type, p_entity_id, p_details, p_ip_address)
  RETURNING id INTO new_id;
  
  RETURN new_id;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION log_activity IS 'Enregistre une action utilisateur dans le journal';

-- Function to check user permission
CREATE OR REPLACE FUNCTION check_user_permission(
  p_user_id INTEGER,
  p_required_role VARCHAR(50)
)
RETURNS BOOLEAN AS $$
DECLARE
  user_role_code VARCHAR(50);
BEGIN
  SELECT r.code INTO user_role_code 
  FROM public.app_user u
  JOIN public.role r ON u.role_id = r.id
  WHERE u.id = p_user_id AND u.is_active = true;
  
  IF user_role_code IS NULL THEN
    RETURN false;
  END IF;
  
  -- Admin has all rights
  IF user_role_code = 'admin' THEN
    RETURN true;
  END IF;
  
  -- Check specific role
  RETURN user_role_code = p_required_role;
END;
$$ LANGUAGE plpgsql;

-- =========================================================
-- 26. VIEWS
-- =========================================================

-- View: User with role and client details
CREATE OR REPLACE VIEW public.user_with_details AS
SELECT 
  u.id as user_id,
  u.email,
  u.is_active,
  u.last_login,
  u.created_at,
  r.id as role_id,
  r.code as role_code,
  r.name as role_name,
  r.redirect_path,
  u.client_id,
  c.name as client_name,
  c.company_name,
  c.email as client_email
FROM public.app_user u
INNER JOIN public.role r ON u.role_id = r.id
LEFT JOIN public.client c ON u.client_id = c.id;

COMMENT ON VIEW public.user_with_details IS 'Vue complète utilisateur avec rôle et client';

-- View: Editorial posts with full context
CREATE OR REPLACE VIEW v_editorial_posts_full AS
SELECT 
  ep.*,
  ec.strategy_id,
  ec.name AS calendar_name,
  sms.client_id,
  c.name AS client_name,
  c.company_name AS client_company
FROM editorial_post ep
JOIN editorial_calendar ec ON ep.calendar_id = ec.id
JOIN social_media_strategy sms ON ec.strategy_id = sms.id
JOIN client c ON sms.client_id = c.id;

COMMENT ON VIEW v_editorial_posts_full IS 'Vue complète des posts avec toutes les informations liées';

-- View: Calendar statistics
CREATE OR REPLACE VIEW v_calendar_statistics AS
SELECT 
  ec.id AS calendar_id,
  ec.strategy_id,
  sms.client_id,
  COUNT(ep.id) AS total_posts,
  COUNT(CASE WHEN ep.status = 'draft' THEN 1 END) AS draft_posts,
  COUNT(CASE WHEN ep.status = 'scheduled' THEN 1 END) AS scheduled_posts,
  COUNT(CASE WHEN ep.status = 'published' THEN 1 END) AS published_posts,
  COUNT(CASE WHEN ep.status = 'cancelled' THEN 1 END) AS cancelled_posts,
  SUM(ep.likes) AS total_likes,
  SUM(ep.comments) AS total_comments,
  SUM(ep.shares) AS total_shares,
  SUM(ep.views) AS total_views,
  AVG(ep.engagement_rate) AS avg_engagement_rate
FROM editorial_calendar ec
LEFT JOIN editorial_post ep ON ec.id = ep.calendar_id
JOIN social_media_strategy sms ON ec.strategy_id = sms.id
GROUP BY ec.id, ec.strategy_id, sms.client_id;

COMMENT ON VIEW v_calendar_statistics IS 'Statistiques agrégées par calendrier éditorial';

-- View: Strategy summary
CREATE OR REPLACE VIEW v_strategy_summary AS
SELECT 
  sms.id,
  sms.client_id,
  sms.status,
  sms.created_at,
  COUNT(DISTINCT p.id) AS nombre_personas,
  COUNT(DISTINCT pc.id) AS nombre_piliers,
  COUNT(DISTINCT k.id) AS nombre_kpis,
  COUNT(DISTINCT ec.id) AS has_calendar
FROM social_media_strategy sms
LEFT JOIN persona p ON sms.id = p.strategy_id
LEFT JOIN pilier_contenu pc ON sms.id = pc.strategy_id
LEFT JOIN kpi k ON sms.id = k.strategy_id
LEFT JOIN editorial_calendar ec ON sms.id = ec.strategy_id
GROUP BY sms.id, sms.client_id, sms.status, sms.created_at;

-- View: Posts by pillar
CREATE OR REPLACE VIEW v_posts_by_pilier AS
SELECT 
  pc.id AS pilier_id,
  pc.strategy_id,
  pc.titre AS pilier_titre,
  COUNT(ep.id) AS nombre_posts,
  COUNT(CASE WHEN ep.status = 'published' THEN 1 END) AS posts_publies,
  COUNT(CASE WHEN ep.status = 'scheduled' THEN 1 END) AS posts_programmes
FROM pilier_contenu pc
LEFT JOIN editorial_post ep ON pc.id = ep.pilier_id
GROUP BY pc.id, pc.strategy_id, pc.titre;

-- View: User statistics
CREATE OR REPLACE VIEW public.user_statistics AS
SELECT 
  r.code as role,
  r.name as role_name,
  COUNT(*) as total_users,
  COUNT(*) FILTER (WHERE u.is_active = true) as active_users,
  COUNT(*) FILTER (WHERE u.last_login > NOW() - INTERVAL '30 days') as active_last_month,
  COUNT(*) FILTER (WHERE u.last_login > NOW() - INTERVAL '7 days') as active_last_week
FROM public.app_user u
JOIN public.role r ON u.role_id = r.id
GROUP BY r.code, r.name;

COMMENT ON VIEW public.user_statistics IS 'Statistiques d''utilisation par rôle';

-- =========================================================
-- 27. ROW LEVEL SECURITY (RLS) - Optional
-- =========================================================

-- Enable RLS on tables
ALTER TABLE editorial_calendar ENABLE ROW LEVEL SECURITY;
ALTER TABLE editorial_post ENABLE ROW LEVEL SECURITY;
ALTER TABLE persona ENABLE ROW LEVEL SECURITY;
ALTER TABLE pilier_contenu ENABLE ROW LEVEL SECURITY;
ALTER TABLE kpi ENABLE ROW LEVEL SECURITY;
ALTER TABLE kpi_mesure ENABLE ROW LEVEL SECURITY;

-- Policies for editorial_calendar
CREATE POLICY "Users can view all calendars" 
ON editorial_calendar FOR SELECT USING (true);

CREATE POLICY "Users can insert calendars" 
ON editorial_calendar FOR INSERT WITH CHECK (true);

CREATE POLICY "Users can update calendars" 
ON editorial_calendar FOR UPDATE USING (true);

CREATE POLICY "Users can delete calendars" 
ON editorial_calendar FOR DELETE USING (true);

-- Policies for editorial_post
CREATE POLICY "Users can view all posts" 
ON editorial_post FOR SELECT USING (true);

CREATE POLICY "Users can insert posts" 
ON editorial_post FOR INSERT WITH CHECK (true);

CREATE POLICY "Users can update posts" 
ON editorial_post FOR UPDATE USING (true);

CREATE POLICY "Users can delete posts" 
ON editorial_post FOR DELETE USING (true);

-- Policies for persona
CREATE POLICY "Users can view all personas" 
ON persona FOR SELECT USING (true);

CREATE POLICY "Users can insert personas" 
ON persona FOR INSERT WITH CHECK (true);

CREATE POLICY "Users can update personas" 
ON persona FOR UPDATE USING (true);

CREATE POLICY "Users can delete personas" 
ON persona FOR DELETE USING (true);

-- Policies for pilier_contenu
CREATE POLICY "Users can view all piliers" 
ON pilier_contenu FOR SELECT USING (true);

CREATE POLICY "Users can insert piliers" 
ON pilier_contenu FOR INSERT WITH CHECK (true);

CREATE POLICY "Users can update piliers" 
ON pilier_contenu FOR UPDATE USING (true);

CREATE POLICY "Users can delete piliers" 
ON pilier_contenu FOR DELETE USING (true);

-- Policies for kpi
CREATE POLICY "Users can view all kpis" 
ON kpi FOR SELECT USING (true);

CREATE POLICY "Users can insert kpis" 
ON kpi FOR INSERT WITH CHECK (true);

CREATE POLICY "Users can update kpis" 
ON kpi FOR UPDATE USING (true);

CREATE POLICY "Users can delete kpis" 
ON kpi FOR DELETE USING (true);

-- Policies for kpi_mesure
CREATE POLICY "Users can view all kpi measures" 
ON kpi_mesure FOR SELECT USING (true);

CREATE POLICY "Users can insert kpi measures" 
ON kpi_mesure FOR INSERT WITH CHECK (true);

CREATE POLICY "Users can update kpi measures" 
ON kpi_mesure FOR UPDATE USING (true);

CREATE POLICY "Users can delete kpi measures" 
ON kpi_mesure FOR DELETE USING (true);

COMMIT;

-- =========================================================
-- VERIFICATION QUERIES
-- =========================================================

-- List all tables created
SELECT 
  schemaname, 
  tablename,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables 
WHERE schemaname = 'public' 
ORDER BY tablename;

-- List all views created
SELECT 
  schemaname, 
  viewname
FROM pg_views 
WHERE schemaname = 'public' 
ORDER BY viewname;

-- List all functions created
SELECT 
  n.nspname as schema,
  p.proname as function_name,
  pg_get_function_arguments(p.oid) as arguments
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname = 'public'
ORDER BY function_name;

-- Verify admin user exists
SELECT 
  u.email,
  r.code as role,
  r.name as role_name,
  u.is_active,
  u.created_at
FROM app_user u
JOIN role r ON u.role_id = r.id
WHERE u.email = 'admin@yourstory.ch';

-- =========================================================
-- SUMMARY
-- =========================================================
-- ✅ All ENUM types created
-- ✅ All core tables created (client, mandat, invoice, expense, etc.)
-- ✅ Authentication system with roles (admin, client, staff)
-- ✅ Social media strategy with editorial calendar
-- ✅ Personas, content pillars, and KPIs tracking
-- ✅ All triggers for timestamp updates
-- ✅ All utility functions
-- ✅ All views for reporting
-- ✅ Row Level Security policies
-- ✅ Default admin user: admin@yourstory.ch / admin123
-- ✅ Default company settings for YourStory Agency
-- =========================================================
-- NEXT STEPS:
-- 1. Configure Supabase connection in .env.local
-- 2. Change admin password immediately
-- 3. Update company_settings with real data
-- 4. Start creating clients and projects
-- =========================================================
